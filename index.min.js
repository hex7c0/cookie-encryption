"use strict";

var arc4 = require("arc4"), autokey = require("autokey"), crypto = require("crypto"), inherits = require("util").inherits, getCipher = new Array([ "arc4", "rc4a", "vmpc", "rc4+" ], crypto.getCiphers(), crypto.getHashes(), [ "modp1", "modp2", "modp5", "modp14", "modp15", "modp16", "modp17", "modp18" ], [ "pbkdf2" ], [ "autokey" ]);

function Main(my) {
    this._my = my, this.cookie = my.cookie, this.encoding = my.encoding, this.decrypt = null, 
    this.encrypt = null, this._cipher = null, this.cache = {
        read: new Object(null),
        write: new Object(null)
    };
}

Main.prototype.flush = function() {
    this.cache = {
        read: new Object(null),
        write: new Object(null)
    };
}, Main.prototype.customization = function(signed) {
    var my = this._my;
    if (my.cipher === getCipher[4][0]) this.encrypt = function(data, encoding) {
        return crypto.pbkdf2Sync(my.cipher, my.extra[0], my.extra[1], my.extra[2]).toString(encoding || this.encoding);
    }, this.decrypt = function() {
        throw new TypeError("Pbkdf2 not supported");
    }; else if (my.cipher === getCipher[5][0]) this._cipher = autokey(my.secret), this.encrypt = function(data, encoding) {
        if ("string" == typeof data) return this._cipher.encodeString(data, "utf8", encoding || this.encoding);
        if (Buffer.isBuffer(data)) return this._cipher.encodeBuffer(data).toString(encoding || this.encoding);
        throw new TypeError("Not a string or buffer");
    }, this.decrypt = function(data, encoding) {
        if ("string" == typeof data) return this._cipher.decodeString(data, encoding || this.encoding);
        throw new TypeError("Not a string or buffer");
    }; else if (getCipher[0].indexOf(my.cipher) >= 0) this._cipher = arc4(my.cipher, my.secret), 
    this.encrypt = function(data, encoding) {
        if ("string" == typeof data) return this._cipher.encodeString(data, "utf8", encoding || this.encoding);
        if (Buffer.isBuffer(data)) return this._cipher.encodeBuffer(data).toString(encoding || this.encoding);
        throw new TypeError("Not a string or buffer");
    }, this.decrypt = function(data, encoding) {
        if ("string" == typeof data) return this._cipher.decodeString(data, encoding || this.encoding);
        throw new TypeError("Not a string or buffer");
    }; else if (getCipher[1].indexOf(my.cipher) >= 0) this.encrypt = function(data, encoding) {
        var encode = encoding || this.encoding, cipher = crypto.createCipher(my.cipher, my.secret);
        return cipher.update(data, "utf8", encode) + cipher.final(encode);
    }, this.decrypt = function(data, encoding) {
        var cipher = crypto.createDecipher(my.cipher, my.secret);
        return cipher.update(data, encoding || this.encoding) + cipher.final();
    }; else if (getCipher[2].indexOf(my.cipher) >= 0) void 0 === my.extra[0] ? (this.encrypt = function(data, encoding) {
        return crypto.createHash(my.cipher).update(data).digest(encoding || this.encoding);
    }, this.decrypt = function() {
        throw new TypeError("Hash not supported");
    }) : (this.encrypt = function(data, encoding) {
        return crypto.createHmac(my.cipher, my.secret).update(data).digest(encoding || this.encoding);
    }, this.decrypt = function() {
        throw new TypeError("Hmac not supported");
    }); else {
        if (!(getCipher[3].indexOf(my.cipher) >= 0)) throw new TypeError("Cipher not supported");
        this.encrypt = function(data, encoding) {
            return crypto.getDiffieHellman(my.cipher).generateKeys().toString(encoding || this.encoding);
        }, this.decrypt = function() {
            throw new TypeError("DiffieHellman not supported");
        };
    }
    this.set = function(res, data, cookie) {
        var my = this._my;
        return res.cookie(cookie || this.cookie, data, {
            domain: my.domain,
            path: my.path,
            maxAge: my.maxAge,
            httpOnly: my.httpOnly,
            secure: my.secure,
            signed: signed
        }), data;
    };
};

function Signed(my) {
    Main.call(this, my), this.customization(!0);
}

inherits(Signed, Main);

function Normal(my) {
    Main.call(this, my), this.customization(!1);
}

inherits(Normal, Main), Signed.prototype.read = function(req, cookie, encoding) {
    var ck, o;
    return void 0 === req.signedCookies || void 0 === (ck = req.signedCookies[cookie || this.cookie]) ? "" : (void 0 === (o = this.cache.read[ck]) && (o = this.cache.read[ck] = this.decrypt(ck, encoding)), 
    o);
}, Normal.prototype.read = function(req, cookie, encoding) {
    var ck, o;
    return void 0 === req.cookies || void 0 === (ck = req.cookies[cookie || this.cookie]) ? "" : (void 0 === (o = this.cache.read[ck]) && (o = this.cache.read[ck] = this.decrypt(ck, encoding)), 
    o);
}, Signed.prototype.write = function(req, data, cookie, encoding) {
    var o, ck = cookie || this.cookie;
    return void 0 === (o = this.cache.write[data]) && (o = this.cache.write[data] = this.encrypt(data, encoding)), 
    req.signedCookies[ck] !== o && (req.signedCookies[ck] = this.set(req.res, o, cookie)), 
    o;
}, Normal.prototype.write = function(req, data, cookie, encoding) {
    var o, ck = cookie || this.cookie;
    return void 0 === (o = this.cache.write[data]) && (o = this.cache.write[data] = this.encrypt(data, encoding)), 
    req.cookies[ck] !== o && (req.cookies[ck] = this.set(req.res, o, cookie)), o;
};

function cookiee(secret, opt) {
    if (!secret) throw new TypeError("secret required");
    var options = opt || Object.create(null), my = {
        secret: Buffer.isBuffer(secret) ? secret : new Buffer(secret),
        cipher: String(options.cipher || "arc4"),
        cookie: String(options.cookie || "vault"),
        domain: String(options.domain || ""),
        path: String(options.path || "/"),
        maxAge: Number(options.maxAge) || 31536e6,
        httpOnly: Boolean(options.httpOnly),
        secure: Boolean(options.secure),
        signed: Boolean(options.signed),
        encoding: String(options.encoding || "hex"),
        extra: !0 === Array.isArray(options.extra) ? options.extra : []
    };
    return Boolean(options.signed) ? new Signed(my) : new Normal(my);
}

module.exports = cookiee;

function getCiphers() {
    return getCipher;
}

module.exports.getCiphers = getCiphers;
